---
layout: post
title:  "CozyHouse"
info: 쇼핑몰[진행 중]
tech: "Java, Spring Boot, Spring Data JPA, Spring Security, MySQL"
type: Team project
---

## 🖥️ 프로젝트 소개
오늘의 집 사이트를 참고하여 사용자에게 다양한 인테리어 상품을 판매하는 웹 애플리케이션을 개발하였습니다.

<br/>

## 🔗 GitHub 주소
[프로젝트 GitHub 저장소](https://github.com/qudgns8883/CozyHouse)

## 📝 노션 주소
[노션](https://www.notion.so/CozyHouse-1011bba98c5780008c91cba0d4993b25)
## 👨‍👩‍👦 프로젝트 구성원
- **팀장**: 김민석 - 프론트엔드 
- **팀원1**: 이병훈 - 백엔드
- **팀원2**: 김준모 - 백엔드

## ⚙️ 사용된 기술
- **Java**: 서버 사이드 애플리케이션 개발
- **Spring Boot**: 애플리케이션의 빠른 설정과 개발을 위한 프레임워크
- **Spring Data JPA**: 데이터베이스와의 상호작용을 위한 ORM
- **Spring Security**: 안전한 인증 및 권한 관리를 위한 보안 프레임워크
- **MySQL**: 데이터 저장을 위한 관계형 데이터베이스

<br/>

# 💡 담당 기능

## 회원가입
- OAuth2 방식을 사용하여 JWT를 이용한 회원가입 기능을 구현하였습니다.
- 모든 회원가입 로직은 백엔드에서 처리하여 데이터의 일관성과 보안을 강화하였습니다.

## 로그인, 소셜로그인, 로그아웃
- OAuth2 방식으로 로그인 및 소셜 로그인 기능을 구현하였습니다.
- JWT를 사용하여 인증 토큰을 관리하고, 모든 인증 관련 로직은 백엔드에서 처리합니다.
- 여러 필터를 커스터마이즈하여 로그인, 로그아웃 및 JWT 검증을 관리합니다.
- 리프레시 토큰을 사용하여 세션 유지 기능을 구현하였으며, 리프레시 토큰 로테이션을 통해 보안성을 강화하였습니다.

## 전역예외처리
- AOP를 활용해 애플리케이션 전반에 걸쳐 발생하는 예외를 처리하여 일관된 오류 응답을 제공합니다.

## 글쓰기
- 파일 업로드를 위해 MultipartFile과 Java NIO를 사용하여 사진 및 문서 파일을 처리합니다.

<br/>

# 🛠️ 트러블슈팅 내용

## 문제 상황 
1. 소셜 로그인 구현 시, 일반 로그인처럼 엑세스토큰과 리프레시토큰을 HTTP 응답 헤더로 받으려 했습니다.
2. 그러나 하이퍼링크로 리다이렉션되는 과정에서 응답 헤더에 직접 접근할 수 없는 상황이 발생했습니다.
3. 이로 인해 JWTFilter는 요청 헤더에서 받은 엑세스 쿠키로 인증을 하게 되었고, 이로 인해 일관성이 떨어지는 문제가 발생했습니다.

## 해결 방안
1. **쿠키를 통한 토큰 전송**  
   - 소셜 로그인 후, 엑세스 토큰과 리프레시 토큰을 서버에서 쿠키로 설정해 클라이언트에 전송했습니다.
   - HttpOnly 속성을 사용하여 JavaScript에서 쿠키에 접근할 수 없도록 설정해 XSS 공격에 대한 보안을 강화했습니다.

2. **엑세스 토큰 요청 헤더로 변환**  
   - 로그인 성공 핸들러를 통해 JWT를 발급하는 방식이 쿠키와 헤더로 다르기 때문에, 쿠키에 저장된 엑세스 토큰을 클라이언트에서 요청 헤더로 변환하여 백엔드에 요청했습니다.  
   - 서버에서 새로운 엑세스 토큰을 응답 헤더로 받아올 수 있도록 하여 JWTFilter의 일관성을 유지하고, 모든 인증 로직을 요청 헤더 방식으로 통합했습니다.  

3. **로컬 스토리지에 저장**  
   - 서버에서 받은 엑세스 토큰은 로컬 스토리지에 저장해 클라이언트에서 쉽게 접근할 수 있도록 설정했습니다.  
   - 로컬 스토리지에 저장된 토큰이 XSS 공격에 노출되지 않도록 콘텐츠 보안 정책(CSP, Content Security Policy)을 설정했습니다.  
   
## 결론
1. 소셜 로그인 과정에서 하이퍼링크로 인한 리다이렉션 문제 때문에, 쿠키를 사용해 토큰을 전송하는 방식을 선택했습니다.
2. 이후, 엑세스 토큰을 요청 헤더로 변환하여 클라이언트에 전달함으로써 일관성을 유지했습니다.
3. 로그인 성공 핸들러에서 JWT 발급 방식을 통합해 JWTFilter의 일관성을 확보했으며, 이는 보안과 사용성을 동시에 고려한 해결책으로 효과적으로 적용되었습니다.

## 느낀 점
1. JWT 토큰을 활용하여 쿠키와 요청 헤더를 조합한 인증 방식이 효과적이라는 것을 깨달았습니다.
2. 특히 HttpOnly 속성의 중요성을 통해 XSS 공격 방어를 강화할 수 있음을 배웠고, CSP(Content Security Policy)와 로컬 스토리지로 클라이언트 측 보안을 높일 수 있었습니다.
3. 이번 경험을 통해 웹 보안의 중요성을 깊이 이해하게 되었고, 앞으로 JWT를 활용해 안전하고 효율적인 시스템을 구축하는 데 기여하고 싶습니다.
